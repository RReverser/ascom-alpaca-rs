/*!
# <%= api.info.title %> <%= api.info.version %>

<%= api.info.description %>
*/

#![allow(
  rustdoc::broken_intra_doc_links,
  clippy::doc_markdown,
)]

use crate::rpc::rpc;

<%
function doc(description) {
  if (description) {
    description = description.trim();
    return description.includes('\n') ? `/**\n${description}\n*/` : `/// ${description}`;
  }
}

let inSchemas = false;

function handleType(schema) {
  let { $ref } = schema;
  if ($ref) {
    let replacement = refReplacements[$ref];
    if (replacement) {
      return handleType(replacement);
    }
    if ($ref === 'void') {
      return '()';
    }
    let match = $ref.match(/^#\/components\/schemas\/(\w+)$/);
    assert.ok(match, `Invalid reference ${$ref}`);
    let typeName = toTypeName(match[1]);
    if (!inSchemas) {
      typeName = `schemas::${typeName}`;
    }
    return typeName;
  }
  switch (schema.type) {
    case 'integer':
      if (schema.enum) break;
      switch (schema.format) {
        case 'uint32':
          return 'u32';
        case 'int32':
        case undefined: // assume that int32 is the default
          return 'i32';
      }
      break;
    case 'array':
      return `Vec<${handleType(schema.items)}>`;
    case 'number':
      return 'f64';
    case 'string':
      return 'String';
    case 'boolean':
      return 'bool';
  }
  console.warn(`Unhandled type`, schema);
  return '()';
}

function handleOptType(schema, required) {
  let type = handleType(schema);
  return required ? type : `Option<${type}>`;
}

function getTypeDescription(schema) {
  if ('description' in schema) {
    return schema.description;
  }
  if (schema.type === 'array') {
    return getTypeDescription(schema.items);
  }
  return '';
}
%>

<% inSchemas = true; %>
#[allow(clippy::as_conversions)]
mod schemas {
  use serde::{Deserialize, Serialize};
  use serde_repr::{Deserialize_repr, Serialize_repr};

  <% for (let [schemaName, schema] of Object.entries(api.components.schemas)) { %>
    <% if (schema['x-kind'] === 'Empty' || schema['x-kind'] === 'ValueResponse') continue; %>
    <% schemaName = toTypeName(schemaName); %>
    <%= doc(schema.description) %>
    <% if (schema.type === 'object') { %>
      #[allow(missing_copy_implementations)]
      #[derive(Debug, Clone, Serialize, Deserialize)]
      pub struct <%= schemaName %> {
        <% for (let [propName, prop] of Object.entries(schema.properties)) { %>
          <%= doc(getTypeDescription(prop)) %>
          #[serde(rename = "<%= propName %>")]
          pub <%= toPropName(propName) %>: <%= handleOptType(prop, schema.required?.includes(propName)) %>,
        <% } %>
      }
    <% } else if (schema.enum) { %>
      <% assert.equal(schema.type, 'integer'); %>
      #[derive(Debug, PartialEq, Eq, Clone, Copy, Serialize_repr, Deserialize_repr)]
      #[repr(i8)]
      pub enum <%= schemaName %> {
        <% for (let [i, value] of schema.enum.entries()) { %>
          <%= doc(schema['x-enum-descriptions']?.[i]) %>
          <%= toTypeName(schema['x-enum-varnames'][i]) %> = <%= value %>,
        <% } %>
      }
    <% } else throw new Error(`Unhandled schema ${schemaName}`); %>
  <% } %>
}
<% inSchemas = false; %>

rpc! {
  <% for (let [groupPath, { description, paths, typeName }] of Object.entries(groupedOps)) { %>
    <%= doc(description) %>
    #[http("<%= groupPath %>")]
    pub trait <%= typeName %>
      <% if (typeName !== 'Device') { %>
        : Device
      <% } %>
    {
      <% for (let { subPath, method, fnName, operation, request, response } of paths) { %>
        <% request = handleType(request); %>
        <% response = handleType(response); %>
        <%= doc(operation.description) %>
        #[http("<%= subPath %>")]
        fn <%= fnName %>(
          &<%= method === 'get' ? '' : 'mut ' %>self,
          <% if (request !== '()') { %>
          request: <%= request %>,
          <% } %>
        )
        <% if (response !== '()') { %>
          -> <%= response %>
        <% } %>
        ;
      <% } %>
    }
  <% } %>
}
